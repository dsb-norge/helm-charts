---
# Number of pods to create:
replicas: 2

# For the pod disruption budget, default is (replicas - 1):
minAvailableReplicas:

# Set to false to avoid creating PodDisruptionBudget for pods
createPodDisruptionBudget: true

# Container image ref for pods
image:

# Container image tag for pods
tag:

# Possibility to override default imagePullPolicy
imagePullPolicy:

# Annotations to put on the Deployment:
deploymentAnnotations:
  # dsb-norge org. in Snyk
  orgs.k8s.snyk.io/v1: 3c6b0e2e-36a2-4c0e-93c8-3ba8c87dd75d

# Annotations to put on every CronJob:
cronJobAnnotations:
  # dsb-norge org. in Snyk
  orgs.k8s.snyk.io/v1: 3c6b0e2e-36a2-4c0e-93c8-3ba8c87dd75d

# Annotations to put on every pod:
# Usage when applying with values.yaml
# podAnnotations:
#   my-custom-key: "my custom value"                  # add custom annotation
#   co.elastic.logs/json.message_key: "my_override"   # override a default
# To remove all defaults and not specify any annotations:
# podAnnotations: null                                # Note that using empty map {} will not work
podAnnotations:
  apparmor.security.beta.kubernetes.io/pod: "runtime/default"
  co.elastic.logs/json.keys_under_root: "true"
  co.elastic.logs/json.overwrite_keys: "true"
  co.elastic.logs/json.add_error_key: "true"

# Default Spring Profile:
springProfiles: "kubernetes"

# It is possible to use a normal yaml tree here, for example:
# root:
#   node1: 1
#   node2: 2
#
# If there is a lot of config, it is useful to use the helm function --set-file.
config:

# Reference secrets that are mounted on the pod:
secretRefs: {}

# Mount certificates as files with additional environment variables to read them in applications
certificates: {}

# Reference configMaps that are mounted on the pod:
configMapRefs: {}

# Hostname must be provided if Ingress should be enabled.
ingress_host:
ingress_path: /

application_web_port: 8080
application_actuator_port: 8180

prometheus_enabled: "false"
prometheus_path: "/actuator/prometheus"

memory_request: "256Mi"
memory_limit: "1024Mi"

cpu_request: "100m"
cpu_limit: "2.5"

# If this is enabled, a docker image with a mssql database is created.
# The following env variables are then added to the pod:
# DATABASE_CONTAINER_USER, DATABASE_CONTAINER_PASSWORD, DATABASE_CONTAINER_HOST_AND_PORT and DATABASE_CONTAINER_DATABASE
database_container:
  enabled: false
  image: "dsbacr.azurecr.io/dsb-norge/dsb-mssql-server:2019-latest"
  # Depends on what image is used:
  database: emptydb               # env: DATABASE_CONTAINER_DATABASE
  user: sa                        # env: DATABASE_CONTAINER_USER
  password: DoN0tUse1Production   # env: DATABASE_CONTAINER_PASSWORD

java_opts:

jobs:

# Reference secrets that are mounted on the cron job pod:
job_secretRefs: {}

liveness_period_seconds: 15
liveness_failure_threshold: 20

readiness_period_seconds: 15
readiness_failure_threshold: 20
